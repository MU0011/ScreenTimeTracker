<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="fantasy-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>スマホ見てるやつ厳しいって</title>
        <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP&display=swap" rel="stylesheet">
        <style>
            body {
                font-family:  'Noto Sans JP', sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #f9f9f9;
                position: relative;
                overflow-x: hidden;
            }
            
            h1, h2, h3 {
                color: #333;
                font-weight: 700;
                margin-bottom: 20px;
            }
            
            h1 {
                font-size: 3.5em;
                text-align: left;
                margin-top: 10px;
            }
            
            .timer {
                font-size: 5em;
                margin: 40px 0;
                font-weight: bold;
                color: #000011;
                text-align: center;
            }
            
            .controls {
                margin: 30px 0;
                text-align: center;
            }
            
            button {
                background-color: #000011;
                color: white;
                border: none;
                padding: 12px 25px;
                margin: 0 10px;
                border-radius: 5px;
                cursor: pointer;
                font-family:  'Noto Sans JP', sans-serif;
                font-size: 1.5em;
                font-weight: 700;
                transition: background-color 0.3s;
            }
            
            button:hover {
                background-color: #000011;
            }
            
            button:disabled {
                background-color: #95a5a6;
                cursor: not-allowed;
            }
            
            .settings {
                margin-top: 40px;
                text-align: left;
                padding: 15px;
                background-color: #ecf0f1;
                border-radius: 8px;
                max-width: 500px;
                margin-left: auto;
                margin-right: auto;
            }
            
            .settings h3 {
                font-size: 2em;
                margin-bottom: 15px;
            }
            
            input[type="number"] {
                width: 80px;
                padding: 8px;
                margin-right: 10px;
                font-family:  'Noto Sans JP', sans-serif;
                font-size: 1.5em;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            
            label {
                font-size: 1.5em;
            }
            
            /* ハンバーガーメニューとサイドパネル */
            .menu-button {
                position: absolute;
                top: 20px;
                right: 20px;
                font-size: 1.8em;
                background: none;
                border: none;
                cursor: pointer;
                z-index: 100;
                padding: 5px 10px;
                background-color: #000011;
                border-radius: 5px;
            }
            
            .side-panel {
                position: fixed;
                top: 0;
                right: -300px;
                width: 300px;
                height: 100%;
                background-color: #fff;
                box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
                transition: right 0.3s ease;
                z-index: 99;
                padding: 20px;
                box-sizing: border-box;
                overflow-y: auto;
            }
            
            .side-panel.open {
                right: 0;
            }
            
            .side-panel h2 {
                font-size: 2.5em;
                margin-top: 50px;
            }
            
            .stats {
                margin-top: 20px;
                font-size: 1.5em;
            }
            
            .notification-test {
                margin-top: 30px;
                text-align: center;
            }
            
            .close-panel {
                position: absolute;
                top: 15px;
                right: 15px;
                font-size: 1.8em;
                background: none;
                border: none;
                cursor: pointer;
                color: #333;
            }
            
            /* オーバーレイ */
            .overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 98;
            }
            
            .overlay.active {
                display: block;
            }
            .auth-modal {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 1000;
                justify-content: center;
                align-items: center;
            }
            
            .auth-container {
                background-color: white;
                padding: 30px;
                border-radius: 10px;
                width: 90%;
                max-width: 400px;
            }
            
            .auth-container h2 {
                margin-top: 0;
                text-align: center;
                font-size: 2em;
            }
            
            .auth-form {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            
            .form-group {
                display: flex;
                flex-direction: column;
            }
            
            .form-group label {
                font-size: 1.2em;
                margin-bottom: 5px;
            }
            
            .form-group input {
                padding: 12px;
                font-size: 1.2em;
                border: 1px solid #ddd;
                border-radius: 5px;
            }
            
            .error-message {
                color: #e74c3c;
                font-size: 1em;
                min-height: 20px;
            }
            
            #registerBtn {
                padding: 12px;
                font-size: 1.5em;
                background-color: #000011;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            }

            /* 友達セクション */
            .friends-section {
                margin-top: 20px;
            }
            
            .action-btn {
                background-color: #000011;
                color: white;
                border: none;
                padding: 10px 15px;
                border-radius: 5px;
                font-size: 1.2em;
                cursor: pointer;
                margin-bottom: 15px;
            }
            
            .friends-list {
                max-height: 200px;
                overflow-y: auto;
                margin-top: 15px;
                background-color: #f4f4f4;
                border-radius: 5px;
                padding: 10px;
            }
            
            .friend-item {
                padding: 8px;
                border-bottom: 1px solid #ddd;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .friend-item:last-child {
                border-bottom: none;
            }
            
            /* 友達検索モーダル */
            .friend-search-modal {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 1000;
                justify-content: center;
                align-items: center;
            }
            
            .friend-search-container {
                background-color: white;
                padding: 30px;
                border-radius: 10px;
                width: 90%;
                max-width: 500px;
            }
            
            .search-form {
                margin: 20px 0;
            }
            
            .search-results {
                max-height: 300px;
                overflow-y: auto;
                margin-top: 20px;
                background-color: #f4f4f4;
                border-radius: 5px;
                padding: 10px;
            }
            
            .search-result-item {
                padding: 10px;
                border-bottom: 1px solid #ddd;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .search-result-item:last-child {
                border-bottom: none;
            }
            
            .search-result-item button {
                background-color: #2ecc71;
                color: white;
                border: none;
                padding: 5px 10px;
                border-radius: 3px;
                cursor: pointer;
            }
            
            #searchQuery {
                padding: 10px;
                width: 70%;
                font-size: 1.1em;
                border: 1px solid #ddd;
                border-radius: 5px;
                margin-right: 10px;
            }
            
            #executeSearchBtn {
                padding: 10px 15px;
                background-color: #000011;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1.1em;
            }
            
            #closeFriendSearchBtn {
                margin-top: 20px;
                padding: 10px 15px;
                background-color: #95a5a6;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1.2em;
                width: 100%;
            }
        </style>
    </head>
    <body>
        <script type="module">
            // Import the functions you need from the SDKs you need
            import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
            import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
            import { 
                getAuth, 
                createUserWithEmailAndPassword, 
                onAuthStateChanged 
            } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
            import { 
                getFirestore, 
                collection, 
                doc, 
                setDoc, 
                getDoc, 
                updateDoc, 
                query, 
                where, 
                getDocs, 
                arrayUnion, 
                arrayRemove 
            } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

            // Your web app's Firebase configuration
            const firebaseConfig = {
            apiKey: "AIzaSyDmpKza5ixbGHmHdO3TOiiBvoBwV0hciPA",
            authDomain: "screentimetracker-daf25.firebaseapp.com",
            projectId: "screentimetracker-daf25",
            storageBucket: "screentimetracker-daf25.firebasestorage.app",
            messagingSenderId: "311529209200",
            appId: "1:311529209200:web:4e29b73c26b9e53a16a3b5",
            measurementId: "G-48V99P52FB"
            };

            // Firebase initialization
            const app = initializeApp(firebaseConfig);
            const analytics = getAnalytics(app);
            const auth = getAuth(app);
            const db = getFirestore(app);

            // Generate random password for security
            function generateRandomPassword(){
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
                let password = '';
                for (let i = 0; i < 12; i++){
                    const randomIndex = Math.floor(Math.random() * chars.length);
                    password += chars[randomIndex];
                }
                return password;
            }

            // Show authentication modal
            function showAuthModal() {
                const authModal = document.getElementById('authModal');
                authModal.style.display = 'flex';
                
                // Register button event listener
                document.getElementById('registerBtn').addEventListener('click', registerUser);
            }

            // Register user
            async function registerUser() {
                const emailInput = document.getElementById('email');
                const usernameInput = document.getElementById('username');
                const errorElement = document.getElementById('authError');
                
                const email = emailInput.value.trim();
                const username = usernameInput.value.trim();
                
                // Input validation
                if (!email || !username) {
                    errorElement.textContent = 'すべての項目を入力してください。';
                    return;
                }
                
                if (!email.endsWith('@gmail.com')) {
                    errorElement.textContent = 'Gmailアドレスを入力してください。';
                    return;
                }
                
                try {
                    // Firebase authentication
                    const password = generateRandomPassword();
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;
                    
                    // Save user data to Firestore
                    await setDoc(doc(db, "users", user.uid), {
                        email: email,
                        username: username,
                        createdAt: new Date().toISOString(),
                        friends: [] // Initialize friends list
                    });
                    
                    // Save registration state to local storage
                    localStorage.setItem('userRegistered', 'true');
                    localStorage.setItem('userId', user.uid);
                    window.currentUserId = user.uid;
                    
                    // Close modal
                    document.getElementById('authModal').style.display = 'none';
                    
                    alert('アカウント登録が完了しました！');
                } catch (error) {
                    console.error('登録エラー:', error);
                    errorElement.textContent = 'アカウント登録に失敗しました: ' + error.message;
                }
            }

            // Friend search modal functions
            function showFriendSearchModal() {
                const modal = document.getElementById('friendSearchModal');
                if (modal) {
                    modal.style.display = 'flex';
                    document.getElementById('searchResults').innerHTML = '';
                    document.getElementById('searchQuery').value = '';
                } else {
                    console.error('Modal element not found');
                }
            }

            function closeFriendSearchModal() {
                document.getElementById('friendSearchModal').style.display = 'none';
            }

            // Search users
            async function searchUsers() {
                const searchQuery = document.getElementById('searchQuery').value.trim();
                const searchResults = document.getElementById('searchResults');
                
                if (!searchQuery) {
                    searchResults.innerHTML = '<p>検索キーワードを入力してください</p>';
                    return;
                }
                
                searchResults.innerHTML = '<p>検索中...</p>';
                
                try {
                    // Get current user ID
                    const currentUserId = window.currentUserId;
                    if (!currentUserId) {
                        searchResults.innerHTML = '<p>認証エラーが発生しました。再ログインしてください。</p>';
                        return;
                    }
                    
                    // Get user's friend list
                    const userRef = doc(db, "users", currentUserId);
                    const userSnap = await getDoc(userRef);
                    
                    if (!userSnap.exists()) {
                        searchResults.innerHTML = '<p>ユーザー情報が見つかりません</p>';
                        return;
                    }
                    
                    const myFriends = userSnap.data().friends || [];
                    
                    // Fix search queries
                    const usersRef = collection(db, "users");
                    
                    // Email exact match
                    const emailQuery = query(usersRef, where("email", "==", searchQuery));
                    const emailQuerySnapshot = await getDocs(emailQuery);
                    
                    // Username prefix match - fix by handling prefix search differently
                    // First get all users (careful with this approach - would need pagination for large datasets)
                    const usersSnapshot = await getDocs(usersRef);
                    
                    // Merge results and remove duplicates
                    const results = new Map();
                    
                    // Add email search results
                    emailQuerySnapshot.forEach(doc => {
                        if (doc.id !== currentUserId) { // Exclude self
                            results.set(doc.id, {
                                id: doc.id,
                                ...doc.data(),
                                isFriend: myFriends.includes(doc.id)
                            });
                        }
                    });
                    
                    // Add username search results (manual filtering for prefix)
                    usersSnapshot.forEach(doc => {
                        if (doc.id !== currentUserId) { // Exclude self
                            const userData = doc.data();
                            if (userData.username && userData.username.toLowerCase().startsWith(searchQuery.toLowerCase())) {
                                results.set(doc.id, {
                                    id: doc.id,
                                    ...userData,
                                    isFriend: myFriends.includes(doc.id)
                                });
                            }
                        }
                    });
                    
                    // Display results
                    if (results.size === 0) {
                        searchResults.innerHTML = '<p>検索結果はありません</p>';
                        return;
                    }
                    
                    let html = '';
                    results.forEach(user => {
                        html += `
                            <div class="search-result-item">
                                <div>
                                    <strong>${user.username}</strong><br>
                                    <small>${user.email}</small>
                                </div>
                                <div>
                                    ${user.isFriend 
                                        ? `<button class="remove-friend-btn" data-id="${user.id}">友達から削除</button>` 
                                        : `<button class="add-friend-btn" data-id="${user.id}">友達に追加</button>`
                                    }
                                </div>
                            </div>
                        `;
                    });
                    
                    searchResults.innerHTML = html;
                    
                    // Add event listeners for add friend buttons
                    document.querySelectorAll('.add-friend-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => addFriend(e.target.dataset.id));
                    });
                    
                    // Add event listeners for remove friend buttons
                    document.querySelectorAll('.remove-friend-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => removeFriend(e.target.dataset.id));
                    });
                    
                } catch (error) {
                    console.error('検索エラー:', error);
                    searchResults.innerHTML = '<p>検索中にエラーが発生しました: ' + error.message + '</p>';
                }
                
            }

            // Add friend
            async function addFriend(friendId) {
                try {
                    const currentUserId = window.currentUserId;
                    
                    // Add to my friend list
                    await updateDoc(doc(db, "users", currentUserId), {
                        friends: arrayUnion(friendId)
                    });
                    
                    // Add me to their friend list (bidirectional friendship)
                    await updateDoc(doc(db, "users", friendId), {
                        friends: arrayUnion(currentUserId)
                    });
                    
                    alert('友達に追加しました！');
                    
                    // Update friend list
                    loadFriendsList();
                    
                    // Update search results
                    searchUsers();
                    
                } catch (error) {
                    console.error('友達追加エラー:', error);
                    alert('友達の追加に失敗しました');
                }
            }

            // Remove friend
            async function removeFriend(friendId) {
                try {
                    const currentUserId = window.currentUserId;
                    
                    // Remove from my friend list
                    await updateDoc(doc(db, "users", currentUserId), {
                        friends: arrayRemove(friendId)
                    });
                    
                    // Remove me from their friend list
                    await updateDoc(doc(db, "users", friendId), {
                        friends: arrayRemove(currentUserId)
                    });
                    
                    alert('友達から削除しました');
                    
                    // Update friend list
                    loadFriendsList();
                    
                    // Update search results
                    searchUsers();
                    
                } catch (error) {
                    console.error('友達削除エラー:', error);
                    alert('友達の削除に失敗しました');
                }
            }

            // Load friends list
            async function loadFriendsList() {
                const friendsList = document.getElementById('friendsList');
                const currentUserId = window.currentUserId;
                
                if (!currentUserId) {
                    friendsList.innerHTML = '<p>ログインしていません</p>';
                    return;
                }
                
                friendsList.innerHTML = '<p>読み込み中...</p>';
                
                try {
                    // Get current user info
                    const userRef = doc(db, "users", currentUserId);
                    const userSnap = await getDoc(userRef);
                    
                    if (!userSnap.exists()) {
                        friendsList.innerHTML = '<p>ユーザー情報が見つかりません</p>';
                        return;
                    }
                    
                    const userData = userSnap.data();
                    const friends = userData.friends || [];
                    
                    if (friends.length === 0) {
                        friendsList.innerHTML = '<p>まだ友達がいません</p>';
                        return;
                    }
                    
                    // Get friend user info - handle each friend individually to avoid errors stopping all
                    let html = '';
                    
                    // Process each friend with individual error handling
                    for (const friendId of friends) {
                        try {
                            const friendRef = doc(db, "users", friendId);
                            const friendSnap = await getDoc(friendRef);
                            
                            if (friendSnap.exists()) {
                                const friend = friendSnap.data();
                                html += `
                                    <div class="friend-item">
                                        <div>${friend.username}</div>
                                        <button class="remove-friend-btn" data-id="${friendSnap.id}">削除</button>
                                    </div>
                                `;
                            }
                        } catch (friendError) {
                            console.warn(`特定の友達(${friendId})の読み込みに失敗しました:`, friendError);
                            // Add a placeholder for this friend
                            html += `
                                <div class="friend-item">
                                    <div>読み込みエラー</div>
                                    <button class="remove-friend-btn" data-id="${friendId}">削除</button>
                                </div>
                            `;
                        }
                    }
                    
                    friendsList.innerHTML = html || '<p>友達情報の読み込みに失敗しました</p>';
                    
                    // Add event listeners for remove friend buttons
                    document.querySelectorAll('.remove-friend-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            removeFriend(e.target.dataset.id);
                        });
                    });
                    
                } catch (error) {
                    console.error('友達リスト読み込みエラー:', error);
                    friendsList.innerHTML = '<p>友達リストの読み込みに失敗しました: ' + error.message + '</p>';
                }
                
            }

            function checkAuthentication() {
                return new Promise((resolve, reject) => {
                    onAuthStateChanged(auth, (user) => {
                        if (user) {
                            window.currentUserId = user.uid;
                            localStorage.setItem('userId', user.uid);
                            resolve(user);
                        } else {
                            window.currentUserId = null;
                            localStorage.removeItem('userId');
                            reject(new Error('Not authenticated'));
                        }
                    }, (error) => {
                        console.error('認証エラー:', error);
                        reject(error);
                    });
                });
            }

            // Add event listeners when DOM is loaded
            document.addEventListener('DOMContentLoaded', async () => {
                try {
                    // Initialize global user ID
                    window.currentUserId = localStorage.getItem('userId');
                    
                    // Add event listeners for friend search modal
                    const searchFriendsBtn = document.getElementById('searchFriendsBtn');
                    const closeFriendSearchBtn = document.getElementById('closeFriendSearchBtn');
                    const executeSearchBtn = document.getElementById('executeSearchBtn');
                    
                    if (searchFriendsBtn) {
                        searchFriendsBtn.addEventListener('click', showFriendSearchModal);
                    }
                    
                    if (closeFriendSearchBtn) {
                        closeFriendSearchBtn.addEventListener('click', closeFriendSearchModal);
                    }
                    
                    if (executeSearchBtn) {
                        executeSearchBtn.addEventListener('click', searchUsers);
                    }
                    
                    // Check authentication state with error handling
                    try {
                        await checkAuthentication();
                        // Only load friends list if authenticated
                        if (window.currentUserId) {
                            loadFriendsList();

                        }
                    } catch (authError) {
                        console.log('認証が必要です:', authError);
                        showAuthModal();
                    }
                } catch (error) {
                    console.error('初期化エラー:', error);
                }
            });
            
            // Export functions to global scope
            window.showFriendSearchModal = showFriendSearchModal;
            window.closeFriendSearchModal = closeFriendSearchModal;
            window.searchUsers = searchUsers;
            window.addFriend = addFriend;
            window.removeFriend = removeFriend;
            window.loadFriendsList = loadFriendsList;

          </script>
        <h1>スマホ見てるやつ厳しいって</h1>
        
        <!-- メニューボタン -->
        <button class="menu-button" id="menuBtn">☰</button>
        
        <!-- メイン画面：タイマーと設定 -->
        <div class="timer" id="timer">00:00:00</div>
        
        <div class="controls">
            <button id="resetBtn">リセット</button>
            <button id="pauseBtn">一時停止</button>
        </div>
        
        <div class="settings">
            <h3>設定</h3>
            <div>
                <label for="timeLimit">目標時間制限: </label>
                <input type="number" id="timeLimit" min="1" max="1440" value="60"> 分
                <button id="saveLimitBtn">保存</button>
            </div>
            <div style="margin-top: 20px;">
                <input type="checkbox" id="notifyEnabled" checked>
                <label for="notifyEnabled">制限時間を超えたら通知する</label>
            </div>
        </div>
        
        <!-- サイドパネル：統計情報と友達機能 -->
        <div class="side-panel" id="sidePanel">
            <button class="close-panel" id="closePanel">✕</button>
            <h2>統計情報</h2>
            <div class="stats">
                <p>今日の利用時間: <span id="todayUsage">0分</span></p>
                <p>今週の利用時間: <span id="weekUsage">0分</span></p>
            </div>
            <h2>友達</h2>
            <div class="friends-section">
                <button id="searchFriendsBtn" class="action-btn">友達を検索</button>
                <div id="friendsList" class="friends-list">
                    <p>読み込み中...</p>
                </div>
            </div>

            
            <div class="notification-test">
                <button id="testNotificationBtn">通知テスト</button>
            </div>
        </div>

        <!-- 友達検索モーダルを追加 -->
        <div class="friend-search-modal" id="friendSearchModal">
            <div class="friend-search-container">
                <h2>友達を検索</h2>
                <div class="search-form">
                    <div class="form-group">
                        <input type="text" id="searchQuery" placeholder="メールアドレスまたはユーザー名で検索">
                        <button id="executeSearchBtn">検索</button>
                    </div>
                    <div class="search-results" id="searchResults">
                        <!-- 検索結果がここに表示されます -->
                    </div>
                </div>
                <button id="closeFriendSearchBtn">閉じる</button>
            </div>
        </div>

        
        <!-- オーバーレイ -->
        <div class="overlay" id="overlay"></div>
        <div class="auth-modal" id="authModal">
            <div class="auth-container">
                <h2>アカウント登録</h2>
                <div class="auth-form">
                    <div class="form-group">
                        <label for="email">Gmail:</label>
                        <input type="email" id="email" placeholder="example@gmail.com" required>
                    </div>
                    <div class="form-group">
                        <label for="username">アカウント名:</label>
                        <input type="text" id="username" placeholder="ニックネーム" required>
                    </div>
                    <div class="error-message" id="authError"></div>
                    <button id="registerBtn">登録</button>
                </div>
            </div>
        </div>
    
        <script>
        // Timer クラス：タイマーの状態と動作を管理
        class Timer {
            constructor(onUpdate, onSave) {
                this.startTime = null;
                this.elapsedTime = 0;
                this.timerInterval = null;
                this.isPaused = false;
                this.pauseTime = null;
                this.visibilityPauseTime = null;
                this.onUpdate = onUpdate;   // タイマー更新時のコールバック
                this.onSave = onSave;       // 保存時のコールバック
                
                // ページの可視性変更イベントリスナー
                // ページの表示状態が変わったときに呼び出される
                //Timer.handleVisiblityChangeを呼び出す
                //bind(this)でthisをTimerにバインド(jsでは関数をイベントに渡すとき元のインスタンスを失う可能性がある)
                document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
            }
            
            // 時間の更新処理
            //目標:タイマーの状態を一秒ごとに更新する
            update() {
                if (document.visibilityState === 'visible' && !this.isPaused) {
                    const now = Date.now();//ページが表示中＆一時停止していないとき
                    //現在の時刻(mmsec)を取得
                    
                    // 非表示状態から復帰した場合の調整
                    //タイマーが見えていない間に進んだ時間を打ち消す処理
                    //もしvisibilityPauseTimeがnullでなければ、
                    //隠れていた時間を計算して、startTimeに加算する
                    //加算したら隠れた時間は除外できたのでnullにする
                    if (this.visibilityPauseTime !== null) {
                        const hiddenDuration = now - this.visibilityPauseTime;
                        this.startTime += hiddenDuration;
                        this.visibilityPauseTime = null;
                    }
                    
                    this.elapsedTime = (now - this.startTime) / 1000;//経過時間(startTimeから現在時刻までの差)を計算して呼び出し
                    //UI側を更新したり、保存したりする処理らしい(?)
                    this.onUpdate(this.elapsedTime);
                    this.onSave();
                }
            }
            
            // タイマーの開始
            start() {
            //startTimeがnullなら計算して代入
            //過去の経過時間を考慮してあたかも止まってなかったかのうように再開する
                if (!this.startTime) {
                    this.startTime = Date.now() - (this.elapsedTime * 1000);
                }
            //timerIntervalがnullなら、1秒ごとにupdateを呼び出すようにする    
                if (!this.timerInterval) {
                    this.timerInterval = setInterval(() => this.update(), 1000);
                }
            //startしたので、isPausedはfalse    
                this.isPaused = false;
            }
            
            // 一時停止/再開の切り替え
            togglePause() {
                if (!this.isPaused) {
                    // 一時停止
                    this.pause();
                    return true; // 一時停止状態になった
                } else {
                    // 再開
                    this.resume();
                    return false; // 実行中状態になった
                }
            }
            
            // 一時停止
            pause() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                this.isPaused = true;
                this.pauseTime = Date.now();
            }
            
            // 再開
            resume() {
                if (this.isPaused && this.pauseTime) {
                    // 一時停止していた時間を考慮して調整
                    const pauseDuration = Date.now() - this.pauseTime;
                    this.startTime += pauseDuration;
                    this.pauseTime = null;
                }
                this.start();
            }
            
            // リセット
            reset() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                this.startTime = null;
                this.elapsedTime = 0;
                this.isPaused = false;
                this.pauseTime = null;
                this.visibilityPauseTime = null;
                this.onUpdate(0);
                this.start();
            }
            
            // 可視性変更のハンドラー
            //ブラウザのタブの表示状態の変化に応じて、タイマーの動作を調整する
            handleVisibilityChange() {
                if (document.visibilityState === 'hidden') {
                    // 非表示になった時間を記録
                    //非表示になった時間を記録して、startTimeを調整する用
                    this.visibilityPauseTime = Date.now();
                    
                    // インターバルを停止（バックグラウンドでの不要な処理を防止）
                    //別タブに移動したりウィンドウを隠したらタイマーを止める
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                        this.timerInterval = null;
                    }
                } else if (document.visibilityState === 'visible') {
                    // 表示状態に戻った場合は、一時停止中でなければタイマー再開
                    if (!this.isPaused) {
                        this.start();
                    }
                }
            }
            
            // 経過時間の取得
            getElapsedTime() {
                return this.elapsedTime;
            }
            
            // 一時停止状態の取得
            getIsPaused() {
                return this.isPaused;
            }
        }
        
        // 通知管理クラス
        class NotificationManager {
            constructor() {
                this.notificationShown = false;//通知がすでに表示されたかどうかを管理する
            }
            
            // 通知権限を確認・リクエスト
            checkPermission() {
                if (Notification.permission !== 'granted') {
                    Notification.requestPermission();//ユーザーに通知を許可してもらうよう要求
                }
            }
            
            // 通知を表示
            showNotification(enabled, timeLimit) {
                if (Notification.permission === 'granted' && enabled && !this.notificationShown) {
                    const notification = new Notification('スクリーンタイム警告', {
                        body: `設定した目標時間(${timeLimit}分)を超えてるって。厳しいって`,
                        icon: 'https://cdn-icons-png.flaticon.com/512/1827/1827504.png'
                    });
                    this.notificationShown = true;
                }
            }
            
            // テスト通知を表示
            showTestNotification() {
                const notification = new Notification('テスト通知', {
                    body: 'これはテスト通知です。実際の警告はこのように表示されます。',
                    icon: 'https://cdn-icons-png.flaticon.com/512/1827/1827504.png'
                });
            }
            
            // 通知状態のリセット
            reset() {
                this.notificationShown = false;
            }
        }
        
        // 統計管理クラス
        class StatsManager {
            constructor(todayElement, weekElement) {
                this.dailyStats = {};
                this.todayElement = todayElement;
                this.weekElement = weekElement;
                this.loadStats();
            }
            
            // 統計データの読み込み
            loadStats() {
                const savedStats = localStorage.getItem('dailyStats');
                if (savedStats) {
                    this.dailyStats = JSON.parse(savedStats);
                }
                this.updateDisplay();
            }
            
            // 本日の統計を更新
            updateTodayStats(elapsedMinutes) {
                const dateKey = this.getTodayKey();
                this.dailyStats[dateKey] = elapsedMinutes;
                this.saveStats();
                this.updateDisplay();
            }
            
            // 統計データを保存
            saveStats() {
                localStorage.setItem('dailyStats', JSON.stringify(this.dailyStats));
            }
            
            // 表示の更新
            updateDisplay() {
                const dateKey = this.getTodayKey();
                
                // 今日の利用時間
                const todayMinutes = this.dailyStats[dateKey] || 0;
                this.todayElement.textContent = `${todayMinutes}分`;
                
                // 今週の利用時間
                const weekMinutes = this.calculateWeekUsage();
                this.weekElement.textContent = `${weekMinutes}分`;
            }
            
            // 今週の利用時間を計算
            calculateWeekUsage() {
                const today = new Date();
                let weekMinutes = 0;
                
                for (let i = 0; i < 7; i++) {
                    const date = new Date(today);
                    date.setDate(today.getDate() - i);
                    const key = date.toISOString().split('T')[0];
                    weekMinutes += this.dailyStats[key] || 0;
                }
                
                return weekMinutes;
            }
            
            // 今日の日付キーを取得
            getTodayKey() {
                return new Date().toISOString().split('T')[0];
            }
        }
        
        // アプリケーションクラス
        class ScreenTimeApp {
            constructor() {
                // DOM要素
                this.timerElement = document.getElementById('timer');
                this.resetBtn = document.getElementById('resetBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.timeLimitInput = document.getElementById('timeLimit');
                this.saveLimitBtn = document.getElementById('saveLimitBtn');
                this.notifyEnabledCheckbox = document.getElementById('notifyEnabled');
                this.todayUsageElement = document.getElementById('todayUsage');
                this.weekUsageElement = document.getElementById('weekUsage');
                this.testNotificationBtn = document.getElementById('testNotificationBtn');
                this.menuBtn = document.getElementById('menuBtn');
                this.sidePanel = document.getElementById('sidePanel');
                this.closePanel = document.getElementById('closePanel');
                this.overlay = document.getElementById('overlay');
                
                // 設定
                this.timeLimit = this.loadTimeLimit();
                
                // 各マネージャーの初期化
                this.notificationManager = new NotificationManager();
                this.statsManager = new StatsManager(this.todayUsageElement, this.weekUsageElement);
                this.timer = new Timer(
                    this.updateTimerDisplay.bind(this),
                    this.saveSession.bind(this)
                );
                
                // イベントリスナーの設定
                this.setupEventListeners();
                
                // 初期化
                this.initialize();
            }
            
            // 初期化
            initialize() {
                this.notificationManager.checkPermission();
                this.timer.start();
            }
            
            // イベントリスナーの設定
            setupEventListeners() {
                this.resetBtn.addEventListener('click', () => this.resetTimer());
                this.pauseBtn.addEventListener('click', () => this.togglePause());
                this.saveLimitBtn.addEventListener('click', () => this.saveTimeLimit());
                this.testNotificationBtn.addEventListener('click', () => {
                    this.notificationManager.showTestNotification();
                });
            // サイドパネルの開閉
                this.menuBtn.addEventListener('click', () => this.openSidePanel());
                this.closePanel.addEventListener('click', () => this.closeSidePanel());
                this.overlay.addEventListener('click', () => this.closeSidePanel());

                // 友達機能のイベントリスナー
                const searchFriendsBtn = document.getElementById('searchFriendsBtn');
                if (searchFriendsBtn) {
                    searchFriendsBtn.addEventListener('click', () => {
                        if (window.showFriendSearchModal) {
                            window.showFriendSearchModal();
                        }
                    });
            }
        }
            //サイドパネルを開く
            openSidePanel(){
                this.sidePanel.classList.add('open');
                this.overlay.classList.add('active');   
            }
            //サイドパネルを閉じる
            closeSidePanel(){
                this.sidePanel.classList.remove('open');
                this.overlay.classList.remove('active');
            }
            
            // タイマー表示の更新
            updateTimerDisplay(elapsedSeconds) {
                const hours = Math.floor(elapsedSeconds / 3600);
                const minutes = Math.floor((elapsedSeconds % 3600) / 60);
                const seconds = Math.floor(elapsedSeconds % 60);
                
                this.timerElement.textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // 分単位での経過時間
                const elapsedMinutes = Math.floor(elapsedSeconds / 60);
                
                // 制限時間チェック
                if (elapsedMinutes >= this.timeLimit) {
                    this.notificationManager.showNotification(
                        this.notifyEnabledCheckbox.checked, 
                        this.timeLimit
                    );
                }
            }
            
            // セッションの保存
            saveSession() {
                const elapsedMinutes = Math.floor(this.timer.getElapsedTime() / 60);
                this.statsManager.updateTodayStats(elapsedMinutes);
            }
            
            // タイマーのリセット
            resetTimer() {
                this.timer.reset();
                this.notificationManager.reset();
            }
            
            // 一時停止/再開の切り替え
            togglePause() {
                const isPaused = this.timer.togglePause();
                this.pauseBtn.textContent = isPaused ? '再開' : '一時停止';
            }
            
            // 目標時間の保存
            saveTimeLimit() {
                const limit = parseInt(this.timeLimitInput.value);
                if (!isNaN(limit) && limit > 0) {
                    this.timeLimit = limit;
                    localStorage.setItem('timeLimit', this.timeLimit);
                    alert(`目標時間を${this.timeLimit}分に設定しました`);
                }
            }
            
            // 目標時間の読み込み
            loadTimeLimit() {
                const savedTimeLimit = localStorage.getItem('timeLimit');
                const defaultLimit = 60;
                
                if (savedTimeLimit) {
                    const limit = parseInt(savedTimeLimit);
                    this.timeLimitInput.value = limit;
                    return limit;
                }
                
                return defaultLimit;
            }
        }
        
        // アプリケーションの起動
        document.addEventListener('DOMContentLoaded', () => {
            const app = new ScreenTimeApp();
        });
    </script>
</body>
</html>